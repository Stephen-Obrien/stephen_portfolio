---
title: "Data Importing Cleaning, and Data Visualization"
format: 
  html:
    self-contained: true
    toc: true
    toc-location: right
    toc-depth: 2
editor: visual
execute:
  warning: false
code-fold: true
theme: mint
---

# linked up.

| Skill | Example |
|----|----|
| I can filter rows from a data frame for a variety of data type (e.g., numeric, integer, character, factor, date). | [missing data](#missingdata) |
| I can modify existing variables and create new variables in a dataframe for. a variety of data types. | [data cleaning example](#college_cleaning) |
| I can use mutating joins to combine multiple data frames. | [pivot longer](#pivotlong_example) |
| I can write well documented and tidy code. |  |
| i can write robust programs that are resistant to changes in inputs | [rescale_column](#rescale_column) |
| I can create visuals for a variety of variable types (e.g., numeric, character, factor, date) and use plot modifications. |  |
| I can create tables that make my summaries clear to the reader. |  |
| I can write concise code that does not repeat itself, iteration and functions to reduce repetition in my code. | [rescale_column](#rescale_column), [`rescale01`](#rescale01)`,` |
|  |  |
|  |  |

# Functions and Fish

The data set used in this section of code includes the fish captured and tagged in various trip from 1989 to 2006 on the Johnsrud and Scotty Brown sections of the Black Foot river. The length, weight, the year it was caught, the section of the river, what number trip of the year it was, and if it had already been marked were recorded for each fish.

```{r setup}
#| include: false

rm(list = ls())
library(tidyverse)
fish <- read_csv(here::here("supporting_artifacts", "ref.work", "lab7", "BlackfootFish.csv" ))
```

## Locating Missing Data {#missingdata}

The missing function written below identify the quantity of missing data for a single variable. It does this by summing the number of NAs within a column.

```{r missing_function}
missing <- function(x) {
  sum(is.na(x))
}
```

The next code chunk applies the missing function across all of the factors. The table is then pivoted so the factors are now a variable and the number of missing data points is another variable. Finally the table is arranged in descending order by the number of missing data points.

```{r missing_table}
#| arrange_nrow: 2
fish |> 
  mutate(
    across(
      .cols = everything(), .fns = ~(missing(.x))
    )
    ) |> 
  distinct(weight, .keep_all = TRUE) |> 
  pivot_longer(
    cols = everything(),
    names_to = "Observation Type",
    values_to = "Missing Data Points"
    ) |> 
  arrange(desc(`Missing Data Points`))
```

The visual generated by the next code chunk represents which variables explain most of the missing data.\
the variables included in the visual are the river section, the year and the trip.

```{r missing_visual}
my_title <- theme(plot.title = element_text(hjust = 0.5, size = 18))

missing_fish <- fish |> 
  filter(is.na(weight == 0)) |> 
  group_by(section, trip, year) |> 
  summarize(weight = sum(is.na(weight)), .groups = "keep") |> 
  ungroup() |> 
  arrange(desc(year)) |> 
  rename("missing" = "weight")

missing_fish |> 
  mutate(trip = as.character(trip)) |> 
  ggplot() +
    geom_col(mapping = aes(x = year, 
                           y =  missing, 
                           fill = trip)) +
    facet_wrap(~section, nrow = 2) + 
    labs(title = "Missing Data Visualization", 
         y = NULL, 
         x = "Year",
         fill = "Trip",
         caption = "*Johnsrud and Scotty Brown
         refer to the section of river") + 
  my_title +
   scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10)
                     )
```

## **Part Two: Adjusting the Data (Function Writing)**

### a) Rescale function. {#rescale01}

the function `rescale01` below replaces the value of each data point with a fraction the is equivelent to the relative distance from the minum value of the range of the data points (0.00 would be the min, 1.00 would be the max). the function first checks to ensure the data is numeric, and has a length greater than 1.

```{r rescale_fun}

rescale01 <- function(x){
  stopifnot(is.numeric(x) | (length(x) > 1) == TRUE) # add check.
  r <- range(x, na.rm = TRUE)
  (x - r[1]) / (r[2] - r[1])
}
```

### b) Simple check for `rescale01` function.

The function is applied to a data set containing the inetergers from 1 to 25 and 1 NA data point.

```{r simple_check}
x <- c(1:25, NA)
rescale01(x)
```

### c) More difficult check

2 bar and whisker plots are created in the next code chunk. Both plots are visualization of the distribution of fish length from the fish data set. the first plot, the one with dark green fill, uses length data after the `rescale01` function was applied. the second plot uses the raw length data. All data points for the dark green plot fall between 0 and 1.

```{r}
#| layout-nrow: 1

fish |> mutate(rescaled = rescale01(length)) |> 
  ggplot() +
  geom_boxplot(
    mapping = aes(x = rescaled), fill = "darkgreen", 
    outlier.color = "darkgreen", outlier.alpha = 0.1
    ) +
  labs(title = "Rescaled Length", x = NULL) +
  theme(axis.text.y = element_text(size = 0)) +
  my_title

fish |>  
  ggplot() +
  geom_boxplot(
    mapping = aes(x = length), fill = "darkred", 
    outlier.color = "darkred",outlier.alpha = 0.1
    ) +
  labs(title = "Orginal Length (cm)") +
  theme(axis.text.y = element_text(size = 0)) +
  my_title
```

### Re-scale function for columns within a data frame. {#rescale_column}

The `rescale0` function from earlier could be applied to a `df` if used within the `mutate( )` function. the `rescale_column` function below can be applied to a set of columns within a data frame without using the mutate function.

```{r}
rescale_column <- function(df, var) {
  df <- df |> mutate(
                across(
                  .cols = {{ var }},
                  .fns = rescale01
                )
    )
  return(df)
}
```

#### `rescale_column` applied.

Below are two lines of code that produce the same data frame.\
The first line of code compared to the second exemplifies the outcome of efficient code and the importance of the function tool for creating concise code. The difference could be much more pronounced more variable needed to be resclaed.

```{r}
fish |> rescale_column(c(length, weight))

fish |> mutate(length = rescale01(length),
               weight = rescale01(weight))
```

# Data Import and Cleaning

## Data download & packages

First, we declare our package dependencies and load the data.

```{r setup_2}
#| warning: false
#| message: false

rm(list = ls())

library(tidyverse)

colleges <- read_csv("https://www.dropbox.com/s/bt5hvctdevhbq6j/colleges.csv?dl=1")
```

## Data cleaning {#college_cleaning}

### There are too many variables in this dataset. We don't need all of them. Narrow your dataset down to only:

-   Name of the institution
-   City, State, and ZIP code of the institution
-   The Admissions Rate
-   The average SAT score
-   The number of undergraduate students
-   The in and out of state tuition
-   Whether the school is public or private
-   The "REGION" variable.

```{r clean_colleges}
# Code combining ALL of your previous steps into ONE pipeline
colleges_clean <- colleges |> 
  select(INSTNM, CITY, STABBR, ZIP,
         ADM_RATE, SAT_AVG, UGDS,
         TUITIONFEE_IN, TUITIONFEE_OUT,
         CONTROL, REGION) |> 
  filter(CONTROL < 3) |> 
   mutate(
    TUITIONFEE_IN = as.numeric(TUITIONFEE_IN),
    TUITIONFEE_OUT = as.numeric(TUITIONFEE_OUT),
    SAT_AVG = as.numeric(SAT_AVG),
    ADM_RATE = as.numeric(ADM_RATE)
    ) |> 
   mutate(
    CONTROL = as.factor(CONTROL),
    REGION = as.factor(REGION)
    ) |> 
  mutate(
    TUITION_DIFF = TUITIONFEE_OUT - TUITIONFEE_IN
  ) |> 
  drop_na() |> print()
```

# Part Two: Identify the mystery college

Wow! Your best friend Ephelia has been accepted to her top choice college! Unfortunately, Ephelia is a very mysterious person, and she won't tell you directly which college this is. You'll have to use her clues to figure out which school is her dream school.

Clues:

1.  This college is located in Region 7.

2.  This college's admission rate is above the median rate for the region.

3.  This college **does not** charge the same for in- and out-of-state tuition.

4.  The average SAT score of this college is an odd number.

5.  This college **is not** in Idaho.

6.  Less than 1,000 people apply to this college every year. (Assume the size of the first year class is 1/4 of the undergraduate population.)

7.  The college **is not** in the state where Dr. Theobold received a Ph.D.

8.  Of the three options remaining at this step, Ephelia will attend the cheapest one.

## 2.a

```{r region,tuition,state}
dream_college <- colleges_clean |> 
  filter(REGION == 7) |>  
  filter(TUITION_DIFF != 0) |> 
  filter(STABBR != "ID")

```

```{r MEDIAN_ADMISSION_RATE}
a.rate <- summarize(colleges_clean, rate = median(ADM_RATE))
dream_college <- dream_college |> 
  filter(ADM_RATE > a.rate$rate)
```

```{r applicants<1000}
frsh <- mutate(dream_college, 
               UGDS = as.double(UGDS)
               )
dream_college <- frsh |> 
  mutate(UGDS = UGDS/ ADM_RATE / 4) |> 
  filter(UGDS < 1000)
```

```{r not.Montana}
dream_college <- dream_college |> 
  filter(STABBR != "MT") |> print()
```
